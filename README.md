![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white)
![Debian](https://img.shields.io/badge/Debian-D70A53?style=for-the-badge&logo=debian&logoColor=white)
![Eclipse](https://img.shields.io/badge/Eclipse-FE7A16.svg?style=for-the-badge&logo=Eclipse&logoColor=white)

Уважаемые проверяющие! 

Представляю Вашему вниманию свой вариант тестового задания.

Вот краткое описание проекта:

1. Логика построена вокруг "шины данных", роль которой играет Queue в классе GamePlayService (Singletone).
2. При запуске приложения создаются три клана (люди, эльфа, гномы), а также потоки, имитирующие пользователей, которые могут прибавлять к золоту клана отрицательную либо положительную дельту.
3. Действие пользователя по изменению золота клана реализуется путем помещения пользователями в шину данных экземпляров класса GoldDeltaCommand, унаследованного от абстрактного класса Command.
	Это похоже на паттерн проектирования "Команда" GoF, но вместо имплементации интерфейса я выбрал наследование от абстрактного класса. На данном этапе это не нужно, но поскольку реальное приложение непременно потребовало бы увеличения возможных действий пользователей, я заложил возможность расширения функционала приложения путем создания других классов, унаследованных от Command.
4. Чтобы потоки, имитирующие пользователей, имели возможность равного доступа к очереди, используется ReentrantLock(true).
5. Когда в очереди накапливается определенное количество команд (в данном случае 1024), создается экземпляр обработчика (класс CommandProcessor), которому передается List таких команд, после чего класс запускается в отдельном потоке. Передачу пакета по времени я не делал, поскольку задание этого не требует, но в реальном приложении необходимо было бы учитывать и временной критерий тоже на случай, если пороговое значение количества команд не будет достигнуто в разумное время. 
6. Логика обработки команд реализована в классе CommandProcessor. В случае появления новых видов команд логику их обработку необходимо будет реализовывать в нем же. 
7. Логирование имитируется с использованием java.util.logging.Logger, который пишет сообщения в консоль (запись в файл существенно замедлила бы работу приложения).
8. В программе предусмотрена задержка выполнения потока, но в представленном варианте она не используется (заданное время задержки 0 мс).
9. Приложение запускалось на компьютере под управлением операционной системы Debian, процессор Intel Core i5 2400, ОЗУ 16ГБ. Работает неограниченно долгое время без сбоев и потери производительности.
10. Как видим, задание реализовано на "голой" Java без использования сторонних библиотек.


 


